// Generated by CoffeeScript 1.3.3
(function() {
  var Enemy, Shot, Stage, T_HEIGHT, T_WIDTH, Tower,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  T_WIDTH = T_HEIGHT = 100;

  Stage = (function() {

    function Stage() {
      this.getElementPosition = __bind(this.getElementPosition, this);

      var cell, geometory, light, material, mesh, row, x, y, _ref, _ref1,
        _this = this;
      this.frame = 0;
      this.map = [[' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], ['S', '→', '→', '→', '→', '→', '→', '→', '→', '→', '↓', ' '], [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '↓', ' '], [' ', ' ', '↓', '←', '←', '←', '←', ' ', ' ', ' ', '↓', ' '], [' ', ' ', '↓', ' ', ' ', ' ', '↑', ' ', ' ', ' ', '↓', ' '], [' ', ' ', '↓', ' ', ' ', ' ', '↑', ' ', ' ', ' ', '↓', ' '], [' ', ' ', '↓', ' ', ' ', ' ', '↑', '←', '←', '←', '←', ' '], [' ', ' ', '↓', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], [' ', ' ', '↓', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], [' ', ' ', '↓', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '], [' ', ' ', '→', '→', '→', '→', '→', '→', '→', '↓', ' ', ' '], [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'G', ' ', ' ']];
      this.scene = new THREE.Scene();
      this.camera = new THREE.PerspectiveCamera(40, document.width / document.height, 1, 10000);
      this.camera.position.z = 1000;
      this.renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      this.renderer.setSize(document.width, document.height);
      document.body.appendChild(this.renderer.domElement);
      light = new THREE.DirectionalLight(0xFFFFFF);
      light.position = {
        x: 100,
        y: 1000,
        z: 1000
      };
      this.scene.add(light);
      this.towers = [];
      this.enemys = [];
      this.planes = [];
      this.start = null;
      geometory = new THREE.PlaneGeometry(T_WIDTH, T_HEIGHT);
      _ref = this.map;
      for (y in _ref) {
        row = _ref[y];
        _ref1 = this.map[y];
        for (x in _ref1) {
          cell = _ref1[x];
          if (cell === ' ') {
            material = new THREE.MeshLambertMaterial({
              color: 0xAAAAAA,
              opacity: 0.2
            });
          } else {
            material = new THREE.MeshLambertMaterial({
              color: 0x00EE00,
              opacity: 0.6
            });
          }
          mesh = new THREE.Mesh(geometory, material);
          mesh.position = {
            x: x * T_WIDTH - 600,
            y: -99,
            z: y * T_HEIGHT - 600
          };
          mesh.rotation.x = 270 * 2 * Math.PI / 360;
          if (cell === 'S') {
            cell = '→';
            this.start = mesh;
          }
          mesh.direction = cell;
          mesh.tile = {};
          mesh.tile.x = parseInt(x);
          mesh.tile.y = parseInt(y);
          this.scene.add(mesh);
          this.planes.push(mesh);
          this.map[y][x] = mesh;
        }
      }
      this.control = new THREE.TrackballControls(this.camera, this.renderer.domElement);
      this.projector = new THREE.Projector();
      this.renderer.domElement.addEventListener("click", function(e) {
        var intersects, mouseX, mouseY, ray, tower, vector;
        mouseX = e.clientX - _this.getElementPosition(_this.renderer.domElement).left;
        mouseY = e.clientY - _this.getElementPosition(_this.renderer.domElement).top;
        x = (mouseX / _this.renderer.domElement.width) * 2 - 1;
        y = -(mouseY / _this.renderer.domElement.height) * 2 + 1;
        vector = new THREE.Vector3(x, y, 1);
        _this.projector.unprojectVector(vector, _this.camera);
        ray = new THREE.Ray(_this.camera.position, vector.subSelf(_this.camera.position).normalize());
        intersects = ray.intersectObjects(_this.planes);
        if (intersects.length > 0 && intersects[0].object.direction === ' ') {
          tower = new Tower(intersects[0].object.position);
          _this.scene.add(tower.mesh);
          _this.towers.push(tower);
          return _this.renderer.render(_this.scene, _this.camera);
        }
      }, false);
    }

    Stage.prototype.getElementPosition = function(element) {
      var left, top;
      top = left = 0;
      while (element) {
        top += element.offsetTop || 0;
        left += element.offsetLeft || 0;
        element = element.offsetParent;
      }
      return {
        top: top,
        left: left
      };
    };

    Stage.prototype.render = function() {
      var enemy, tower, _i, _len, _ref;
      if ((this.frame++ % 180) === 0) {
        enemy = new Enemy(this.map, this.start);
        enemy.nextTile();
        this.scene.add(enemy.mesh);
        this.enemys.push(enemy);
      }
      if ((this.frame % 10) === 0) {
        _ref = this.towers;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          tower = _ref[_i];
          tower.aim();
        }
      }
      this.control.update();
      TWEEN.update();
      return this.renderer.render(this.scene, this.camera);
    };

    return Stage;

  })();

  Tower = (function() {

    function Tower(position) {
      var geometry, material;
      this.height = 100;
      geometry = new THREE.CylinderGeometry(0, 20, this.height, 0, 0, false);
      material = new THREE.MeshLambertMaterial({
        color: Math.random() * 0xffffff
      });
      this.mesh = new THREE.Mesh(geometry, material);
      this.mesh.position.copy(position);
      this.mesh.position.y += this.height / 2;
    }

    Tower.prototype.aim = function() {
      var distance, enemy, i, xx, zz, _ref;
      _ref = stage.enemys;
      for (i in _ref) {
        enemy = _ref[i];
        xx = enemy.mesh.position.x - this.mesh.position.x;
        zz = enemy.mesh.position.z - this.mesh.position.z;
        distance = Math.sqrt(Math.pow(xx, 2) + Math.pow(zz, 2));
        if (distance <= 300) {
          stage.scene.add(new Shot(this.mesh.position, enemy.mesh.position).mesh);
          return true;
        }
      }
    };

    return Tower;

  })();

  Shot = (function() {

    function Shot(start, end) {
      var geometry, material,
        _this = this;
      geometry = new THREE.SphereGeometry(5, 3, 3);
      material = new THREE.MeshBasicMaterial({
        color: 0x6666ff
      });
      this.mesh = new THREE.Mesh(geometry, material);
      this.mesh.position.copy(start);
      this.tween = new TWEEN.Tween(this.mesh.position).to({
        x: end.x,
        y: end.y,
        z: end.z
      }, 100).onComplete(function() {
        return _this.destroy();
      }).easing(TWEEN.Easing.Linear.EaseNone).start();
    }

    Shot.prototype.destroy = function() {
      return stage.scene.remove(this.mesh);
    };

    return Shot;

  })();

  Enemy = (function() {

    function Enemy(map, tile) {
      var geometry, material;
      this.height = 100;
      this.map = map;
      this.tile = tile;
      geometry = new THREE.SphereGeometry(30, 7, 7);
      material = new THREE.MeshBasicMaterial({
        color: 0xff6666,
        wireframe: true,
        wireframeLinewidth: 0.1
      });
      this.mesh = new THREE.Mesh(geometry, material);
      this.mesh.position.copy(this.tile.position);
      this.mesh.position.y += this.height / 2;
    }

    Enemy.prototype.nextTile = function() {
      var xx, zz,
        _this = this;
      xx = 0;
      zz = 0;
      if (this.tile.direction === '←') {
        xx = -1;
      }
      if (this.tile.direction === '→') {
        xx = +1;
      }
      if (this.tile.direction === '↑') {
        zz = -1;
      }
      if (this.tile.direction === '↓') {
        zz = +1;
      }
      this.tile = this.map[this.tile.tile.y + zz][this.tile.tile.x + xx];
      return this.tween = new TWEEN.Tween(this.mesh.position).to({
        x: this.tile.position.x,
        z: this.tile.position.z
      }, 1000).onComplete(function() {
        return _this.nextTile();
      }).easing(TWEEN.Easing.Linear.EaseNone).start();
    };

    return Enemy;

  })();

  this.stage = new Stage();

  this.addEventListener("DOMContentLoaded", function() {
    this.stage.render();
    return (function(stage) {
      return setInterval(function() {
        return stage.render();
      }, 10);
    })(this.stage);
  });

}).call(this);
